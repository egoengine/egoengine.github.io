<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EgoEngine</title>
<style>
  :root{
    --divider-x: 50vw;
    --bg:#0b0b0c;
    --line:rgba(255,255,255,.95);
    --cell: calc(100vw / 6);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#eaeaea;font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}

  /* ===== HERO (unchanged layout, now light-load) ===== */
  .hero{ position:relative; width:100vw; height:100vh; overflow:hidden; }
  .stage{
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    width:100vw; height:calc(100vw / 2);
  }
  .brand{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:100; pointer-events:none; }
  .brand .wordmark{
    font-weight:900; font-size:clamp(42px,10vw,120px); line-height:1;
    background:linear-gradient(180deg,#fff,#dfe5ff);
    -webkit-background-clip:text; background-clip:text; color:transparent;
    text-shadow:0 10px 32px rgba(0,0,0,.45);
  }
  .grid{
    position:absolute; inset:0;
    display:grid; grid-template-columns:repeat(6, var(--cell));
    grid-auto-rows:var(--cell); gap:0;
  }
  .tile{ position:relative; overflow:hidden; background:#000; }
  .tile video{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; display:block; background:#000; }
  .tile video.base{ z-index:1; }
  .tile video.overlay{ z-index:2;
    clip-path: polygon(0 0, var(--cut,0px) 0, var(--cut,0px) 100%, 0 100%);
    will-change:clip-path;
  }
  #divider{ position:absolute; top:0; bottom:0; left: calc(var(--divider-x) - 1px);
    width:2px; background:var(--line); pointer-events:none; z-index:2; }

  /* Hide scrollbars */
  html, body{ -ms-overflow-style:none; scrollbar-width:none; }
  html::-webkit-scrollbar, body::-webkit-scrollbar{ width:0; height:0; background:transparent; }

  /* ===== AFTER-HERO HEADING (unchanged look) ===== */
  .after-hero { background:#fff; color:#111; padding:5vh 0; }
  .fancy-title{
    margin:5vh auto; max-width:80%; text-align:center;
    font-size:clamp(28px,4vw,56px); font-weight:900; line-height:1.2;
    background:linear-gradient(90deg,#2c2c54,#443377,#5a2a5a);
    -webkit-background-clip:text; background-clip:text; color:transparent;
    text-shadow:0 4px 12px rgba(0,0,0,.2);
    animation:title-glow 6s ease-in-out infinite alternate;
  }
  @keyframes title-glow {
    from { text-shadow:0 0 14px rgba(68,51,119,.6),0 0 28px rgba(90,42,90,.5),0 0 42px rgba(68,51,119,.4); }
    to   { text-shadow:0 0 22px rgba(90,42,90,.8),0 0 44px rgba(68,51,119,.7),0 0 60px rgba(90,42,90,.6); }
  }

  /* ===== NEW: Real-World Tasks layout ===== */
  .tasks{ max-width:min(1200px,92vw); margin:0 auto 8vh; }
  .tasks h2{
    font-size:clamp(22px,2.6vw,32px); margin:0 0 6px; font-weight:800;
    letter-spacing:.2px;
  }
  .task{ margin:32px 0 48px; }
  .task h3{
    margin:12px 0 18px; font-size:clamp(18px,2.2vw,24px); font-weight:800;
  }
  .demos{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(420px,1fr));
    gap:16px;
  }
  .card{
    background:#0f0f12; color:#eee; border:1px solid rgba(255,255,255,.08);
    border-radius:16px; overflow:hidden; box-shadow:0 6px 24px rgba(0,0,0,.15);
  }
  .card .meta{
    padding:10px 14px; display:flex; align-items:center; justify-content:space-between;
    border-bottom:1px solid rgba(255,255,255,.06); font-size:14px; color:#bbb;
  }
  .dual{
    display:grid; grid-template-columns:1fr 1fr; gap:4px; padding:8px; background:#000;
  }
  .pane{
    position:relative; width:100%;
    aspect-ratio:16/9; background:#000; overflow:hidden; border-radius:10px;
  }
  .pane video{
    position:absolute; inset:0; width:100%; height:100%; object-fit:cover; display:block;
    background:#000;
  }
  .labels{
    position:absolute; top:6px; left:6px; padding:3px 6px; font-size:12px;
    background:rgba(0,0,0,.55); color:#fff; border-radius:6px; pointer-events:none;
  }
  details.extras{ padding:0 8px 8px; }
  details.extras summary{
    cursor:pointer; user-select:none; padding:10px 6px; color:#cbd3ff; font-size:14px;
  }
  .quad{
    display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-top:6px;
  }
  .small .pane{ aspect-ratio:16/9; }
  .ghost{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    font-size:12px; color:#888; background:linear-gradient(180deg,#101014,#0b0b0f);
  }
  .badge{
    padding:4px 8px; border:1px solid rgba(255,255,255,.15); border-radius:999px;
    font-size:12px; color:#999;
  }
  .hint{ font-size:12px; color:#7d7d7d; padding:0 14px 12px; }

  .real-caption{
    padding:8px 14px; font-size:14px; color:#bbb; border-top:1px solid rgba(255,255,255,.06);
  }

  /* ==== Real Robot Demos: 4-in-a-row under each task ==== */
  .subhead{
    margin: 10px 2px 8px;
    font-size:14px; font-weight:700;
    color:#9aa4ff;              /* darker than #cbd3ff */
    letter-spacing:.2px;
  }
  .real-block{
    background:#000;            /* match the inpainted dual's black panel */
    border-radius:16px;
    padding:8px;
    margin:12px 0 32px; 
  }
  .real-row{
    display:grid;
    grid-template-columns:repeat(4, minmax(0, 1fr)); /* exactly 4 in one line */
    gap:4px;                      /* match .dual gap */
    overflow:hidden;
  }
  .real-row .pane{
    height:clamp(110px, 18vw, 160px);
    border-radius:10px;
    background:#000; position:relative; overflow:hidden;
  }
  .real-row .pane video{
    position:absolute; inset:0; width:100%; height:100%; object-fit:cover;
  }


  /* Small screens: stack the two main panes vertically */
  @media (max-width:560px){
    .dual{ grid-template-columns:1fr; }
  }
</style>
</head>
<body>

  <!-- ===== HERO / TEASER ===== -->
  <section class="hero" id="hero">
    <div class="stage" id="stage">
      <div class="brand"><div class="wordmark">EgoEngine</div></div>
      <div id="divider"></div>
      <main id="grid" class="grid"></main>
    </div>
  </section>

  <div class="after-hero">
    <div class="fancy-title">
      EgoEngine: From Egocentric Human Videos to High-Fidelity Dexterous Robot Demonstrations
    </div>

    <!-- ===== Real-World Tasks Section ===== -->

    <p style="text-align:center;margin:16px 0 24px;">
      <a href="games/real-or-not.html" style="
        display:inline-block;
        padding:15px 21px;                /* 1.5× padding */
        border-radius:999px;
        background:#0f0f12;
        border:1px solid rgba(255,255,255,.15);
        color:#cbd3ff;
        text-decoration:none;
        font-weight:800;
        font-size:1.5em;                  /* 1.5× text */
        line-height:1.4;                  /* keeps it balanced */
      ">
        Real or Not: Click to Play!
      </a>
    </p>


    <section class="tasks" id="tasks">
      <h2>Real-World Tasks</h2>
      <div class="hint">Left: <strong>original</strong> (human foreground). Right: <strong>inpainted</strong> (robot foreground).</div>

      <!-- Mustard -->
      <div class="task" id="task-mustard">
        <h3>Mustard <span class="badge"></span></h3>
        <div class="demos" id="mustard-demos"></div>
      </div>

      <!-- Drawer -->
      <div class="task" id="task-drawer">
        <h3>Drawer <span class="badge"></span></h3>
        <div class="demos" id="drawer-demos"></div>
      </div>
    </section>

    <!-- your other content below -->
    <section id="below"><div style="height:150vh"></div></section>
  </div>

<script>
  /* ============= HERO (light-load + per-tile sync) ============= */
  const ROOT_HUMAN = 'videos/blending/human';
  const FOLDERS_HUMAN = [
    'Cassie-bartending','Cassie-bartending2','Cassie-blinds','Cassie-boardgame','Cassie-cat2','Cassie-cat_food',
    'Cassie-cooking2','Cassie-door','Cassie-earbuds','Cassie-eyedrops','Cassie-flower','Cassie-fridge',
    'Cassie-laptop','Cassie-microwave','Cassie-oven','Cassie-subway','Cassie-yogurt','Cassie-Rowan-Allen',
  ];

  // HERO 专用懒加载观察器（只负责把 data-src → src）
  const heroLazyObserver = ('IntersectionObserver' in window) ? new IntersectionObserver((entries)=>{
    entries.forEach(entry=>{
      const v = entry.target;
      if (entry.isIntersecting && v.dataset.src && !v.src){
        v.src = v.dataset.src;
        v.load();
        if (v.autoplay) v.play().catch(()=>{});
        heroLazyObserver.unobserve(v);
      }
    });
  }, { rootMargin: '200px 0px' }) : null;

  // 小工具：创建轻载入视频（HERO 版）
  function makeHeroLazyVideo(src, cls){
    const v = document.createElement('video');
    v.className = cls || '';
    v.autoplay = true; v.loop = true; v.muted = true; v.playsInline = true;
    v.setAttribute('muted',''); v.setAttribute('playsinline','');
    v.preload = 'metadata';     // 轻载入以便拿到时长、首帧用于对齐
    v.controls = false;
    v.dataset.src = src;        // 等 observer 挂上
    if (heroLazyObserver) heroLazyObserver.observe(v); else { v.src = src; }
    v.addEventListener('ended', () => { v.currentTime = 0; v.play().catch(()=>{}); });
    return v;
  }

  // === REPLACE your entire SyncGroup with this one-shot version ===
class SyncGroup {
  constructor(clock){
    this.clock = clock;
    this.members = new Set();
    this._aligned = new WeakSet(); // 记录已进行过一次性对齐的成员

    // 只传播 播放/暂停/倍速（不再 timeupdate/seek 对齐）
    clock.addEventListener('play',  () => { this._alignAllOnce(); this._propagatePlay(true); });
    clock.addEventListener('pause', () => this._propagatePlay(false));
    clock.addEventListener('ratechange', () => this._propagateRate());
  }

  add(v){
    if (!v || v === this.clock || this.members.has(v)) return;
    this.members.add(v);

    // 成员就绪时做一次性对齐（若 clock 已经 ready）
    const alignOnReady = () => this._alignOnce(v);
    v.addEventListener('loadeddata', alignOnReady, { once:true });
    v.addEventListener('canplay',    alignOnReady, { once:true });

    // 保持循环，但不再强制对齐
    v.addEventListener('ended', ()=>{
      v.currentTime = (this.clock.currentTime % (v.duration || 1));
      v.play().catch(()=>{});
    });
  }

  // 兼容你现有的调用：现在只做一次性对齐（若未对齐过）
  resyncMember(v){ this._alignOnce(v); }

  _alignOnce(v){
    if (!v || this._aligned.has(v) || v.readyState < 2 || this.clock.readyState < 2) return;
    v.currentTime = this.clock.currentTime;          // 仅在开始时对齐一次
    this._aligned.add(v);
    if (this.clock.paused) v.pause(); else v.play().catch(()=>{});
    v.playbackRate = this.clock.playbackRate;
  }

  _alignAllOnce(){ this.members.forEach(v => this._alignOnce(v)); }

  _propagatePlay(playing){
    this.members.forEach(v => playing ? v.play().catch(()=>{}) : v.pause());
  }

  _propagateRate(){
    this.members.forEach(v => v.playbackRate = this.clock.playbackRate);
  }
}


  const stage = document.getElementById('stage');
  const grid  = document.getElementById('grid');

  (function buildHero(){
    for (const name of FOLDERS_HUMAN){
      const tile = document.createElement('div'); tile.className = 'tile';
      const base = makeHeroLazyVideo(`${ROOT_HUMAN}/${name}/inpainted_video.mp4`, 'base');
      const over = makeHeroLazyVideo(`${ROOT_HUMAN}/${name}/cropped_video.mp4`,   'overlay');
      tile.append(base, over);
      grid.appendChild(tile);

      // 每个 tile 自己的同步（用 overlay 作为 clock，或 base 均可）
      const group = new SyncGroup(over);
      group.add(base);
      // 首次可播放时再对齐一次
      const trySync = ()=>{ group.resyncMember(base); };
      over.addEventListener('loadeddata', trySync, { once:true });
      base.addEventListener('loadeddata', trySync, { once:true });
    }
    requestAnimationFrame(()=>{ updateDivider(); updateClips(); updatePlayback(); });
  })();

  // HERO 的分割线 & 解码负载控制（保持你的逻辑）
  let cutX = Math.round(window.innerWidth * 0.5);
  function updateDivider(){ stage.style.setProperty('--divider-x', cutX + 'px'); }
  function updateClips(){
    document.querySelectorAll('.tile').forEach(tile=>{
      const r = tile.getBoundingClientRect();
      const local = Math.max(0, Math.min(r.width, cutX - r.left));
      tile.style.setProperty('--cut', local + 'px');
    });
  }
  function setPlaying(v, shouldPlay){ if (!v) return; shouldPlay ? v.play().catch(()=>{}) : v.pause(); }
  function updatePlayback(){
    document.querySelectorAll('.tile').forEach(tile=>{
      const base = tile.querySelector('video.base');
      const over = tile.querySelector('video.overlay');
      const r = tile.getBoundingClientRect();
      const cutLocal = Math.max(0, Math.min(r.width, cutX - r.left));
      setPlaying(over, cutLocal > 0);
      setPlaying(base, cutLocal < r.width);
    });
  }
  function setCutFrom(x){
    const bounds = stage.getBoundingClientRect();
    const clamped = Math.max(bounds.left, Math.min(bounds.right, x));
    cutX = clamped; updateDivider(); updateClips(); updatePlayback();
  }
  stage.addEventListener('mousemove', e => setCutFrom(e.clientX));
  stage.addEventListener('touchstart', e => e.touches[0] && setCutFrom(e.touches[0].clientX), {passive:true});
  stage.addEventListener('touchmove',  e => e.touches[0] && setCutFrom(e.touches[0].clientX), {passive:true});
  window.addEventListener('resize', () => { updateDivider(); updateClips(); updatePlayback(); });
  document.addEventListener('visibilitychange', ()=>{ if (!document.hidden) document.querySelectorAll('video').forEach(v=> v.play().catch(()=>{})); });

  /* ============= NEW: Real-World Tasks ============= */
  const ROOT_ROBOT = 'videos/blending'; // base
  const TASKS = [
    { key:'mustard', label:'Mustard', ids:[1,2,3,4] },
    { key:'drawer',  label:'Drawer',  ids:[1,2,3,4] },
  ];

  // —— 懒加载观察器（任务区）——
  const lazyObserver = ('IntersectionObserver' in window) ? new IntersectionObserver((entries)=>{
    entries.forEach(entry=>{
      const v = entry.target;
      if (entry.isIntersecting && v.dataset.src && !v.src){
        v.src = v.dataset.src;
        v.load();
        if (v.autoplay) v.play().catch(()=>{});
        lazyObserver.unobserve(v);
      }
    });
  }, { rootMargin: '200px 0px' }) : null;

  // —— 视口播放/暂停（任务区）——
  const playObserver = ('IntersectionObserver' in window) ? new IntersectionObserver((entries)=>{
    entries.forEach(entry=>{
      const v = entry.target;
      if (!v) return;
      if (entry.isIntersecting){
        const group = v.closest('.card')?.syncGroup;
        if (group) group.resyncMember(v); // 进入视口时对齐时间戳
        if (v.autoplay) v.play().catch(()=>{});
      } else {
        v.pause();
      }
    });
  }, { threshold: 0.2 }) : null;

  // 任务区视频：统一懒加载 & 出视口暂停
  function makeLazyVideo(src, cls, role, demoId){
    const v = document.createElement('video');
    v.className = cls || '';
    v.dataset.role = role || '';
    v.dataset.demoId = demoId || '';
    v.muted = true; v.autoplay = true; v.loop = true; v.playsInline = true;
    v.setAttribute('muted',''); v.setAttribute('playsinline','');
    v.preload = 'none';
    v.controls = false;
    v.dataset.src = src;
    if (lazyObserver) lazyObserver.observe(v); else { v.src = src; }
    if (playObserver) playObserver.observe(v);
    v.addEventListener('ended', ()=>{ v.currentTime = 0; v.play().catch(()=>{}); });
    return v;
  }

  // 任务区也用同一个同步器类（上面已定义）
  function buildCard(taskKey, id){
    const base = `${ROOT_ROBOT}/${taskKey}/${id}`;
    const card = document.createElement('div'); card.className = 'card';

    const meta = document.createElement('div'); meta.className = 'meta';
    meta.innerHTML = `<span>#${id}</span><span>${taskKey}</span>`;
    card.appendChild(meta);

    // main two videos
    const dual = document.createElement('div'); dual.className = 'dual';
    const leftPane  = document.createElement('div'); leftPane.className = 'pane';
    const rightPane = document.createElement('div'); rightPane.className = 'pane';

    const vCropped   = makeLazyVideo(`${base}/cropped_video.mp4`, 'v v-cropped', 'cropped', id);
    const vInpainted = makeLazyVideo(`${base}/inpainted_video.mp4`, 'v v-inpainted', 'inpainted', id);

    leftPane.append(vCropped);  leftPane.appendChild(labelEl('Cropped'));
    rightPane.append(vInpainted); rightPane.appendChild(labelEl('Inpainted'));
    dual.append(leftPane, rightPane);
    card.appendChild(dual);

    // sync group using cropped as clock
    const group = new SyncGroup(vCropped);
    group.add(vInpainted);
    card.syncGroup = group;

    // collapsible extras (mask + removed)
    const det = document.createElement('details'); det.className = 'extras';
    const sum = document.createElement('summary'); sum.textContent = 'Mask & Background';
    det.appendChild(sum);

    const quad = document.createElement('div'); quad.className = 'quad small';
    const p1 = document.createElement('div'); p1.className = 'pane';
    const p2 = document.createElement('div'); p2.className = 'pane';

    // placeholders until opened (keeps DOM light)
    p1.appendChild(ghostEl('mask_5.mp4'));
    p2.appendChild(ghostEl('removed_w_mask_5.mp4'));
    quad.append(p1, p2);
    det.appendChild(quad);
    card.appendChild(det);

    // when toggled
    det.addEventListener('toggle', ()=>{
      // 关闭：释放资源（卸载 src、释放解码器，同时把地址放回 data-src 以便下次懒加载）
      if (!det.open) {
        [p1, p2].forEach(p=>{
          const v = p.querySelector('video');
          if (!v) return;
          v.pause();
          const src = v.src || v.dataset.src || '';
          v.removeAttribute('src');
          v.load();                 // 释放 decoder
          v.dataset.src = src;      // 保留路径，供下次重新懒加载
          // 重新注册懒加载和出视口暂停观察
          if (lazyObserver) lazyObserver.observe(v);
          if (playObserver) playObserver.observe(v);
        });
        return;
      }

      // 打开：首次创建并加入同步
      if (!p1.dataset.loaded) {
        p1.dataset.loaded = '1'; p2.dataset.loaded = '1';
        p1.innerHTML = ''; p2.innerHTML = '';
        const vMask    = makeLazyVideo(`${base}/mask_5.mp4`, 'v v-mask', 'mask', id);
        const vRemoved = makeLazyVideo(`${base}/removed_w_mask_5.mp4`, 'v v-removed', 'removed', id);
        p1.append(vMask);  p1.appendChild(labelEl('Mask'));
        p2.append(vRemoved); p2.appendChild(labelEl('Removed hands'));

        group.add(vMask); group.add(vRemoved);
        const trySync = ()=>{ group.resyncMember(vMask); group.resyncMember(vRemoved); };
        vMask.addEventListener('loadeddata', trySync, { once:true });
        vRemoved.addEventListener('loadeddata', trySync, { once:true });
        trySync();
      }
    });

    return card;
  }

  function labelEl(text){
    const l = document.createElement('div'); l.className = 'labels'; l.textContent = text; return l;
  }
  function ghostEl(text){
    const g = document.createElement('div'); g.className = 'ghost'; g.textContent = text; return g;
  }

  function buildTasks(){
    const mustardWrap = document.getElementById('mustard-demos');
    const drawerWrap  = document.getElementById('drawer-demos');
    TASKS[0].ids.forEach(id => mustardWrap.appendChild(buildCard('mustard', id)));
    TASKS[1].ids.forEach(id => drawerWrap.appendChild(buildCard('drawer',  id)));
  }

    /* ==== Real Robot Demos (per task, 4-in-a-row) ==== */
  /* Map both tasks here. Update file names/paths as you add reals. */
  const REAL_DEMOS = {
    mustard: { root: 'videos/blending/mustard/real', files: ['mustard1.mp4','mustard2.mp4','mustard3.mp4','mustard4.mp4'] },
    drawer:  { root: 'videos/blending/drawer/real',  files: ['drawer1.mp4','drawer2.mp4','drawer3.mp4','drawer4.mp4'] }, // rename to your actual files
  };

  /* Release logic (uses your existing lazyObserver & playObserver) */
  const releaseTimeoutMs = 8000;
  const offscreenTimers = new WeakMap();
  function unloadVideo(v){
    try{
      v.pause();
      const src = v.src || v.dataset.src || '';
      v.removeAttribute('src');
      v.load();               // release decoder
      v.dataset.src = src;    // keep path for re-lazyload
      if (lazyObserver) lazyObserver.observe(v);
      if (playObserver) playObserver.observe(v);
    }catch(_){}
  }
  const releaseObserver = ('IntersectionObserver' in window) ? new IntersectionObserver((entries)=>{
    entries.forEach(entry=>{
      const v = entry.target; if (!v) return;
      if (entry.isIntersecting){
        const t = offscreenTimers.get(v); if (t) { clearTimeout(t); offscreenTimers.delete(v); }
      }else{
        const prev = offscreenTimers.get(v); if (prev) clearTimeout(prev);
        const tid = setTimeout(()=>{ unloadVideo(v); offscreenTimers.delete(v); }, releaseTimeoutMs);
        offscreenTimers.set(v, tid);
      }
    });
  }, { threshold: 0.0 }) : null;

  function buildRealRow(taskKey, cfg){
    const taskEl = document.getElementById(`task-${taskKey}`);
    if (!taskEl) return;

    // Black block wrapper
    const block = document.createElement('div');
    block.className = 'real-block';

    // Title INSIDE the block
    const sub = document.createElement('div');
    sub.className = 'subhead';
    sub.textContent = 'Real Robot Demos';
    block.appendChild(sub);

    // Row of 4 inside the block
    const row = document.createElement('div');
    row.className = 'real-row';
    row.id = `${taskKey}-real-row`;

    (cfg.files || []).forEach((f, i) => {
      const pane = document.createElement('div'); pane.className = 'pane mini';
      const v = makeLazyVideo(`${cfg.root}/${f}`, 'v v-real', `${taskKey}-real`, i+1);
      pane.appendChild(v);
      pane.appendChild(labelEl(`#${i+1}`));
      row.appendChild(pane);
      if (releaseObserver) releaseObserver.observe(v);
    });

    block.appendChild(row);

    // Insert at TOP of the task (right after <h3>, before .demos)
    const h3 = taskEl.querySelector('h3');
    if (h3){
      h3.insertAdjacentElement('afterend', block);
    } else {
      taskEl.prepend(block);
    }
  }


  /* Build rows for all configured tasks */
  function buildRealRows(){
    Object.entries(REAL_DEMOS).forEach(([key, cfg])=>{
      if (cfg.files && cfg.files.length) buildRealRow(key, cfg);
    });
  }


  buildTasks();
  buildRealRows();

</script>
</body>
</html>
